---
title: "포워드, 리다이렉트"
date: 2025-06-09
tags: []
author: "이의민"
---

이번에 주신 이미지는 **웹 개발 모델**과 **MVC 패턴**에 대해 설명하고 있습니다. 웹 애플리케이션 개발이 어떻게 발전해왔는지를 보여주는 중요한 내용입니다.

---

### **웹 개발 모델**

웹 개발 모델은 웹 애플리케이션의 구조를 어떻게 설계하고 기능을 분리할 것인가에 대한 접근 방식입니다. 이미지에서는 크게 세 가지 모델을 제시하고 있습니다.

#### **모델 1**

* **설명**:
    * 기존의 JSP만으로 구현한 웹 애플리케이션의 초기 구조입니다.
    * 웹 브라우저의 요청을 JSP 페이지가 받아서 처리하는 구조입니다.
    * JSP 페이지 하나에서 비즈니스 로직(데이터 처리, 계산 등)과 프리젠테이션 로직(화면에 결과 출력) 코드가 모두 섞여 있는 형태입니다.
    * 모델 1에서는 JSP 페이지가 핵심적인 역할(컨트롤러 + 뷰)을 수행합니다.

* **모델 1의 구조 및 요청 처리 흐름**:
    1.  **클라이언트 (웹 브라우저) 요청**: 클라이언트가 웹 서버로 요청을 보냅니다.
    2.  **JSP 페이지 (컨트롤러 + 뷰)**: JSP 페이지가 이 요청을 직접 받아서 처리합니다.
    3.  **모델 (자바빈즈)**: JSP 페이지 내에서 필요한 경우 자바빈즈(비즈니스 로직 담당)를 호출하여 데이터베이스 작업을 수행합니다.
    4.  **데이터베이스**: 데이터베이스와 상호작용하여 데이터를 조회하거나 조작합니다.
    5.  **응답**: JSP 페이지가 처리 결과를 직접 HTML 형태로 웹 브라우저에 출력하여 응답합니다.

* **문제점**: 비즈니스 로직과 화면 표시 로직이 섞여 있어 코드가 복잡해지고, 유지보수 및 확장이 어렵습니다. 또한 디자이너와 개발자의 협업이 어렵습니다.

#### **모델 2**

* **설명**:
    * 클라이언트의 요청 처리, 응답 처리, 비즈니스 로직 처리 부분을 모듈화한 구조입니다.
    * 요청 처리를 담당하는 컨트롤러(서블릿)와 결과 출력을 담당하는 뷰(JSP 페이지)로 역할을 분리했습니다.
    * 모든 흐름을 제어하는 데 서블릿이 중요한 역할을 합니다.

* **모델 2의 구조 및 요청 처리 흐름**:
    1.  **클라이언트 (웹 브라우저) 요청**: 클라이언트가 웹 서버로 요청을 보냅니다.
    2.  **컨트롤러 (서블릿)**: 모든 요청은 서블릿(컨트롤러)이 받습니다. 서블릿은 요청을 분석하고 어떤 비즈니스 로직을 수행할지 결정합니다.
    3.  **모델 (자바빈즈)**: 컨트롤러는 필요한 경우 자바빈즈(모델)를 호출하여 비즈니스 로직을 수행하고 데이터를 처리합니다.
    4.  **데이터베이스**: 모델은 데이터베이스와 상호작용합니다.
    5.  **뷰 (JSP 페이지)**: 비즈니스 로직 처리 후, 컨트롤러는 데이터를 뷰(JSP 페이지)에 전달하고, 뷰 페이지로 제어를 넘겨 최종적으로 화면을 구성하여 클라이언트에 응답합니다. 서블릿은 직접 화면을 출력하지 않고, JSP가 출력을 담당합니다.

* **장점**: 역할 분리가 명확하여 코드의 재사용성, 유지보수성, 확장성이 향상됩니다. 개발자와 디자이너의 협업이 용이해집니다.

#### **MVC (Model-View-Controller) 패턴**

* **설명**:
    * `Model`, `View`, `Controller`의 약자입니다.
    * 웹 애플리케이션을 비즈니스 로직, 프리젠테이션 로직, 데이터로 분리하는 디자인 패턴입니다. 모델 2가 바로 이 MVC 패턴의 대표적인 구현 방식입니다.
    * **웹 애플리케이션의 구성요소를 다음 세 가지 역할로 분류**:
        * **비즈니스 로직 (Model)**: 애플리케이션의 핵심 로직과 데이터를 처리합니다. 사용자 정보 관리, 주문 정보 처리 등 실제 업무와 관련된 데이터를 다루고 처리하는 부분입니다. 주로 자바 클래스(POJO), 데이터베이스 연동(DAO), 서비스 계층(Service) 등으로 구성됩니다.
        * **프리젠테이션 로직 (View)**: 사용자에게 애플리케이션의 데이터를 어떻게 보여줄지 정의합니다. 사용자가 어떤 형태로 데이터를 보고 상호작용하는지(UI/UX)를 결정합니다. 주로 JSP, HTML, CSS, JavaScript 등으로 구성됩니다. 화면에 데이터를 표시하고 사용자의 입력을 받는 역할을 합니다.
        * **요청 처리 (Controller)**: 클라이언트의 요청을 받아서 모델과 뷰 사이의 상호작용을 제어합니다. 사용자의 요청을 분석하고, 해당 요청을 처리할 모델을 호출하며, 모델이 처리한 결과를 어떤 뷰를 통해 사용자에게 보여줄지 결정합니다. 주로 서블릿이나 스프링의 `@Controller` 등으로 구현됩니다.

* **장점**:
    * **높은 모듈성**: 각 계층이 독립적으로 개발되고 변경될 수 있어 코드 간의 결합도가 낮아집니다.
    * **유지보수 용이성**: 각 역할이 명확히 분리되어 있어, 문제 발생 시 해당 계층만 수정하면 되므로 유지보수가 편리합니다.
    * **확장성**: 새로운 기능을 추가하거나 기존 기능을 변경할 때 다른 계층에 미치는 영향을 최소화할 수 있습니다.
    * **재사용성**: 비즈니스 로직(모델)은 여러 뷰나 컨트롤러에서 재사용될 수 있습니다.
    * **협업 용이성**: 개발자(모델, 컨트롤러)와 디자이너(뷰)가 독립적으로 작업할 수 있어 협업 효율이 높아집니다.

이러한 웹 개발 모델의 발전은 웹 애플리케이션의 복잡성이 증가함에 따라 효율적인 개발과 유지보수를 위한 설계 원칙의 중요성을 보여줍니다.

---

### **MVC 패턴의 구성 요소**

MVC(Model-View-Controller)는 애플리케이션을 세 가지 핵심 구성 요소로 분리하여 개발 효율성과 유지보수성을 높이는 디자인 패턴입니다.

* **모델 (Model)**
    * **설명**: 애플리케이션의 **데이터와 비즈니스 로직**을 담당하는 객체입니다.
    * 사용자가 무엇을 요청하든, 요청 처리의 핵심이 되는 데이터(데이터베이스 연동, 데이터 조회/수정 등)와 관련된 작업을 수행합니다.
    * 예를 들어, 사용자 정보, 상품 정보, 주문 정보 등을 다루는 부분입니다.

* **컨트롤러 (Controller)**
    * **설명**: 클라이언트로부터의 요청을 받아서 **모델과 뷰 사이의 상호작용을 조정하는 역할**을 합니다.
    * 사용자의 요청(예: URL 입력, 버튼 클릭)을 분석하여 어떤 비즈니스 로직을 수행할지 결정하고, 그에 맞는 모델을 호출합니다.
    * 모델로부터 처리 결과를 받은 후, 사용자에게 응답할 **적절한 뷰를 선택하고 해당 모델의 데이터를 뷰로 전달하는 역할**을 합니다.
    * 주로 **서블릿(Servlet)**이 이 역할을 담당합니다.

* **뷰 (View)**
    * **설명**: 사용자에게 **모델의 정보(데이터)를 보여주는 역할**을 합니다.
    * 비즈니스 로직을 포함하지 않고, 단순히 모델이 전달해준 데이터를 기반으로 화면을 구성합니다.
    * 하나의 모델을 다양한 뷰에서 사용할 수 있습니다. (예: 동일한 상품 데이터를 웹 페이지, 모바일 앱, 인쇄용 문서 등 다양한 형태로 보여줄 수 있습니다.)
    * 주로 **JSP(JavaServer Pages)**가 이 역할을 담당합니다.

---

### **요청 포워딩 (Request Forwarding)**

요청 포워딩은 클라이언트의 요청을 다른 리소스(서블릿, JSP 등)로 전달하는 서버 내부의 기술입니다.

#### **요청 포워딩의 필요성**

* **요청 처리 작업의 모듈화**: 하나의 요청을 처리하기 위해 여러 서블릿이나 JSP가 협력하여 작업을 분담할 수 있게 합니다.
* **모듈의 재사용성 증가 및 유지 보수의 편의**: 각 모듈(서블릿, JSP)이 자신의 역할에만 집중할 수 있게 하여 코드의 재사용성을 높이고 유지보수를 용이하게 합니다.
* **MVC 모델 (Model2)의 기본 기능**: MVC 모델(Model2)에서는 컨트롤러(서블릿)가 요청을 받아 비즈니스 로직을 처리한 후, 최종적으로 화면을 보여줄 뷰(JSP)로 제어를 넘기기 위해 요청 포워딩을 사용합니다.
    * **요청 처리**: `FrontController` (모든 요청을 받는 서블릿)에서 담당합니다.
    * **응답 처리**: `JSP` (뷰)에서 담당합니다.

#### **요청 포워딩 방법**

1.  **`RequestDispatcher` 클래스를 이용한 forward 방법**:
    * **설명**: 가장 일반적인 포워딩 방법입니다. 클라이언트의 요청이 서버 내부에서 한 리소스에서 다른 리소스로 완전히 전환됩니다. 클라이언트(브라우저)는 이러한 내부적인 전환을 알지 못하며, 브라우저의 URL 주소는 변경되지 않습니다.
    * **사용 예시**:
        ```java
        RequestDispatcher dispatcher = req.getRequestDispatcher(target); // target은 이동할 JSP/서블릿 경로
        dispatcher.forward(req, res); // 요청(req)과 응답(res) 객체를 넘겨줌
        ```
    * **특징**:
        * 컨트롤러(서블릿)가 비즈니스 로직을 처리한 후, 그 결과를 `request` 객체에 저장하고(예: `request.setAttribute("데이터이름", 데이터값);`) 뷰(JSP)로 포워딩하여 뷰에서 이 데이터를 공유하고 활용할 수 있습니다.
        * 클라이언트로부터 받은 `request` 객체와 `response` 객체가 다음 리소스로 **그대로 전달**됩니다.
        * 클라이언트 입장에서는 하나의 요청에 대한 응답이므로, 브라우저 주소창의 URL은 변경되지 않습니다.
        * 서버 내부에서 제어를 넘기는 방식이므로, `request`와 `response` 객체의 정보가 유지되어 다음 페이지에서 이전 페이지의 데이터를 사용할 수 있습니다.

2.  **`HttpServletResponse` 클래스를 이용한 redirect 방법**:
    * 이 방법은 이미지에는 상세히 설명되어 있지 않지만, `forward`와 대조되는 중요한 요청 처리 방식입니다.
    * **설명**: 서버가 클라이언트에게 "다른 URL로 다시 요청을 보내세요"라고 지시하는 방식입니다.
    * **사용 예시**: `response.sendRedirect("이동할_URL");`
    * **특징**:
        * 클라이언트(브라우저)가 새로운 URL로 다시 요청을 보내게 되므로, 브라우저 주소창의 URL이 변경됩니다.
        * 이전 요청의 `request` 객체는 소멸되고, 새로운 `request` 객체가 생성됩니다. 따라서 이전 요청의 `request` 속성으로 저장된 데이터는 공유되지 않습니다. (`GET` 방식으로 파라미터를 추가하여 전달할 수는 있습니다.)
        * 주로 웹 페이지 이동, 로그인 성공 후 메인 페이지로 이동, 게시글 작성 후 목록 페이지로 이동 등 "새로운 요청"을 만들어야 할 때 사용됩니다.

`forward`와 `redirect`는 모두 웹 페이지의 흐름을 제어하는 데 사용되지만, 동작 방식과 데이터 공유 방식에 큰 차이가 있으므로 상황에 맞게 적절히 선택하여 사용해야 합니다.
