---
title: "REST-API"
date: 2025-04-02
tags: [RESTAPI]
author: "이의민"
---
REST API(Representational State Transfer Application Programming Interface)는 웹 서비스에서 데이터를 주고받기 위한 아키텍처 스타일 중 하나로, HTTP 프로토콜을 기반으로 설계됩니다. REST는 간단하고 확장 가능하며, 클라이언트와 서버 간의 통신을 효율적으로 처리할 수 있는 방식으로 널리 사용됩니다. 주로 웹 애플리케이션, 모바일 앱, IoT 디바이스 등에서 데이터를 교환할 때 활용됩니다.

### REST API의 주요 특징
1. **자원(Resource) 중심**: REST에서는 모든 데이터를 "자원"으로 표현하며, 각 자원은 고유한 URI(Uniform Resource Identifier)로 식별됩니다. 예를 들어, `/users/123`은 ID가 123인 사용자를 나타낼 수 있습니다.
2. **HTTP 메서드 사용**: REST API는 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용해 자원에 대한 작업을 정의합니다.
   - **GET**: 자원을 조회 (예: 사용자 목록 가져오기)
   - **POST**: 자원을 생성 (예: 새 사용자 추가)
   - **PUT**: 자원을 수정 (예: 사용자 정보 업데이트)
   - **DELETE**: 자원을 삭제 (예: 사용자 삭제)
3. **상태 비저장(Stateless)**: 클라이언트와 서버 간의 각 요청은 독립적이며, 이전 요청에 대한 정보를 서버가 유지하지 않습니다. 필요한 모든 정보는 요청 자체에 포함되어야 합니다.
4. **표준화된 응답 형식**: 주로 JSON이나 XML 형식으로 데이터를 주고받습니다. JSON이 더 가볍고 읽기 쉬워 현재 더 널리 사용됩니다.
5. **클라이언트-서버 분리**: 클라이언트(프론트엔드)와 서버(백엔드)가 명확히 분리되어 독립적으로 개발 및 배포가 가능합니다.

### REST API의 동작 예시
예를 들어, 온라인 서점의 REST API가 있다고 가정해봅시다:
- `GET /books`: 모든 책 목록을 조회
- `GET /books/456`: ID가 456인 책의 세부 정보 조회
- `POST /books`: 새로운 책 추가 (요청 본문에 책 정보 포함)
- `PUT /books/456`: ID가 456인 책 정보 수정
- `DELETE /books/456`: ID가 456인 책 삭제

### REST API의 장점
- **단순성**: HTTP를 기반으로 하므로 별도의 복잡한 프로토콜이 필요 없음.
- **확장성**: 서버와 클라이언트가 독립적이어서 시스템 확장이 용이.
- **호환성**: 다양한 플랫폼과 언어에서 쉽게 사용 가능.

### RESTful API란?
"RESTful"이라는 용어는 REST 원칙을 잘 따르는 API를 의미합니다. REST 설계 지침(예: 상태 비저장, 자원 중심, 적절한 HTTP 메서드 사용 등)을 준수하면 RESTful API라고 부를 수 있습니다.

### RESTful API의 정보 구현 제한과 단점

RESTful API는 많은 장점을 가지고 있지만, 정보 구현과 관련해 몇 가지 제한과 단점이 존재합니다. 아래에서 주요 단점을 설명하겠습니다:

1. **오버페칭(Over-fetching)과 언더페칭(Under-fetching)**:
   - REST API는 고정된 엔드포인트에서 데이터를 반환하므로, 클라이언트가 필요로 하는 데이터보다 더 많거나 적은 데이터를 받을 수 있습니다.
   - **오버페칭**: 예를 들어, `/users/123` 엔드포인트가 사용자 이름, 이메일, 주소 등 모든 정보를 반환하는데, 클라이언트가 이름만 필요할 경우 불필요한 데이터까지 전송받게 됩니다.
   - **언더페칭**: 반대로, 필요한 데이터가 여러 엔드포인트에 나뉘어 있을 경우, 클라이언트는 여러 번 요청을 보내야 합니다(예: `/users/123`과 `/users/123/orders`를 따로 호출).
   - 이로 인해 네트워크 부하가 증가하거나 응답 시간이 길어질 수 있습니다.

2. **유연성 부족**:
   - RESTful API는 자원과 엔드포인트 구조가 서버 측에서 미리 정의되므로, 클라이언트의 요구사항이 변경되면 API를 수정하거나 새 엔드포인트를 추가해야 합니다. 이는 빠르게 변화하는 프론트엔드 요구사항에 대응하기 어렵게 만듭니다.

3. **버전 관리 문제**:
   - 데이터 구조나 엔드포인트가 변경될 경우, REST API는 보통 버전 관리를 통해 이를 처리합니다(예: `/v1/users` → `/v2/users`). 하지만 이는 API 유지보수를 복잡하게 만들고, 클라이언트가 최신 버전으로 전환해야 하는 부담을 줄 수 있습니다.

4. **복잡한 관계 데이터 처리의 어려움**:
   - REST는 자원 중심이기 때문에, 복잡한 데이터 관계(예: 사용자와 그 사용자의 주문 내역, 리뷰 등을 한 번에 조회)를 처리하려면 여러 요청이 필요하거나, 서버에서 커스텀 엔드포인트를 만들어야 합니다.

---

### GraphQL에 대한 설명

GraphQL은 이러한 RESTful API의 단점을 해결하기 위해 Facebook에서 개발된 쿼리 언어이자 API 접근 방식입니다. GraphQL은 클라이언트가 필요한 데이터를 정확히 요청할 수 있게 해주는 유연한 대안으로 주목받고 있습니다.

#### GraphQL의 주요 특징
1. **클라이언트 중심 데이터 요청**:
   - 클라이언트는 쿼리를 통해 원하는 데이터의 구조와 필드를 정확히 지정할 수 있습니다. 예를 들어, 사용자 이름과 이메일만 필요하면 이를 명시적으로 요청 가능:
     ```graphql
     query {
       user(id: "123") {
         name
         email
       }
     }
     ```
   - 결과적으로 오버페칭과 언더페칭 문제를 해결합니다.

2. **단일 엔드포인트**:
   - REST와 달리 GraphQL은 보통 단일 엔드포인트(예: `/graphql`)를 사용하며, 쿼리와 뮤테이션(Mutation)을 통해 모든 작업을 처리합니다. 이는 복잡한 엔드포인트 관리가 필요 없게 만듭니다.

3. **강력한 타입 시스템**:
   - GraphQL은 스키마를 정의하여 데이터의 구조와 타입을 명확히 지정합니다. 클라이언트와 서버 간의 계약이 명확해지고, 문서화도 자동으로 제공됩니다.

4. **실시간 데이터 지원**:
   - GraphQL은 Subscription을 통해 실시간 업데이트(예: 채팅 메시지나 주식 가격 변동)를 쉽게 구현할 수 있습니다.

#### GraphQL의 동작 예시
- 요청:
  ```graphql
  query {
    user(id: "123") {
      name
      orders {
        id
        total
      }
    }
  }
  ```
- 응답:
  ```json
  {
    "data": {
      "user": {
        "name": "John Doe",
        "orders": [
          { "id": "1", "total": 29.99 },
          { "id": "2", "total": 15.50 }
        ]
      }
    }
  }
  ```

#### GraphQL의 장점
- **효율성**: 클라이언트가 필요한 데이터만 요청하므로 네트워크 사용량 감소.
- **유연성**: 프론트엔드 개발자가 원하는 대로 데이터를 조합해 요청 가능.
- **단순화된 API 관리**: 여러 엔드포인트 대신 단일 엔드포인트로 모든 요청 처리.

#### GraphQL의 단점
- **복잡성 증가**: 서버 측에서 스키마와 리졸버(Resolver)를 설계해야 하므로 초기 설정이 REST보다 복잡할 수 있습니다.
- **캐싱 어려움**: REST는 HTTP 캐싱을 쉽게 활용할 수 있지만, GraphQL은 단일 엔드포인트와 동적 쿼리로 인해 캐싱이 더 복잡합니다(별도 솔루션 필요).
- **과도한 요청 처리 부담**: 클라이언트가 복잡한 쿼리를 보내면 서버에 부하가 커질 수 있습니다.

---

### RESTful API vs GraphQL 요약
- **RESTful API**: 단순한 자원 중심 접근이 필요한 경우, 기존 인프라와의 호환성을 중시할 때 적합.
- **GraphQL**: 클라이언트 요구사항이 다양하고, 데이터 조회의 유연성이 중요한 경우에 유리.

JSON Server는 가짜 REST API를 빠르게 생성할 수 있는 도구로, JSON 파일을 데이터베이스처럼 사용해 개발 및 테스트에 유용합니다. 글로벌 설치와 로컬 설치 방식이 있습니다. 아래에서 간략히 설명합니다.

### JSON서버 구동

### 글로벌 설치 (Global)
- **설치 방법**: `npm install -g json-server`
- **특징**: 
  - 시스템 전체에서 `json-server` 명령어를 사용할 수 있음.
  - 한 번 설치하면 어떤 프로젝트 폴더에서든 실행 가능.
- **실행 예시**: 
  - `json-server --watch db.json`
  - `db.json` 파일을 기반으로 API 서버가 시작됨.
- **장점**: 여러 프로젝트에서 재사용 가능, 별도 설치 없이 바로 사용.
- **단점**: 글로벌 환경에 의존하므로 버전 충돌 가능성 있음.

### 로컬 설치 (Local)
- **설치 방법**: 프로젝트 폴더에서 `npm install json-server --save-dev`
- **특징**: 
  - 특정 프로젝트에만 종속적으로 설치됨.
  - `package.json`에 스크립트를 추가해 실행 (예: `"start": "json-server --watch db.json"`).
- **실행 예시**: 
  - `npm start` (스크립트 설정 후).
- **장점**: 프로젝트별로 독립적인 버전 관리 가능, 팀원 간 환경 일관성 유지.
- **단점**: 각 프로젝트마다 설치 필요, 초기 설정 약간 번거로움.

### 공통점
- 둘 다 `db.json` 같은 파일을 읽어 RESTful 엔드포인트(예: GET `/posts`, POST `/posts`)를 자동 생성.
- 개발 중 백엔드 API가 없어도 프론트엔드 작업 가능.

**선택 기준**: 간단한 테스트라면 글로벌, 프로젝트별 관리 필요 시 로컬 추천!
---

페이지네이션(Pagination)은 대량의 데이터를 효율적으로 관리하고 표시하기 위해 데이터를 작은 단위(페이지)로 나누는 기술입니다. 주로 웹 애플리케이션이나 API에서 사용됩니다.

### 주요 개념
- **목적**: 사용자가 한 번에 모든 데이터를 로드하지 않고, 필요한 만큼만 조회해 성능을 최적화하고 사용자 경험을 개선.
- **구현 방식**: 
  - 데이터를 페이지 단위로 분할 (예: 1페이지에 10개 항목).
  - 클라이언트는 페이지 번호와 페이지 크기를 요청 (예: `GET /posts?page=2&limit=10`).
  - 서버는 해당 범위의 데이터만 반환.

### 예시
- 요청: `GET /posts?page=1&limit=10`
  - 응답: 1~10번째 게시물 반환.
- 요청: `GET /posts?page=2&limit=10`
  - 응답: 11~20번째 게시물 반환.

### 장점
- 서버 부하 감소.
- 빠른 데이터 로딩.
- 사용자 친화적 (무한 스크롤 대신 명확한 탐색 가능).

### 단점
- 추가적인 요청 필요.
- 복잡한 데이터 동기화 시 구현 어려움.

REST API나 JSON Server에서도 쉽게 적용 가능하며, 프론트엔드와 백엔드 간 협력으로 동작합니다!

---

### 크로스 오리진
크로스 오리진(Cross-Origin)은 웹 보안과 관련된 개념으로, 서로 다른 출처(Origin) 간의 리소스 요청 및 접근을 다룹니다. 아래에서 간략히 설명드릴게요.

### 크로스 오리진이란?
- **출처(Origin)**: 프로토콜(예: `http`, `https`), 도메인(예: `example.com`), 포트(예: `80`, `443`)의 조합.
  - 예: `https://example.com:443`과 `http://example.com`은 다른 출처.
- **정의**: 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 리소스를 요청하는 상황.
  - 예: `https://app.com`에서 `https://api.com/data`로 요청.

### Same-Origin Policy (동일 출처 정책)
- 브라우저는 보안상 기본적으로 동일 출처에서만 리소스 요청을 허용합니다.
- 크로스 오리진 요청은 제한되며, 이를 우회하려면 서버와 클라이언트 간 협력이 필요합니다.

### 크로스 오리진 문제 (CORS)
- **CORS (Cross-Origin Resource Sharing)**: 크로스 오리진 요청을 안전하게 허용하기 위한 메커니즘.
- **발생 상황**: 
  - 예: `https://frontend.com`에서 `https://api.com`으로 Fetch/Axios 요청 시, 브라우저가 "CORS 오류"를 발생시킬 수 있음.
- **해결 방법**:
  - 서버에서 `Access-Control-Allow-Origin` 헤더를 설정해 허용 출처 명시.
    - 예: `Access-Control-Allow-Origin: https://frontend.com` 또는 `*` (모두 허용).
  - 프리플라이트(Preflight) 요청: `OPTIONS` 메서드로 서버가 요청을 허용하는지 확인.

### 예시
- **요청**: `fetch('https://api.com/data')` (출처: `https://frontend.com`).
- **오류**: 서버가 CORS를 허용하지 않으면 "No 'Access-Control-Allow-Origin' header" 오류 발생.
- **해결**: 서버에서 응답 헤더에 `Access-Control-Allow-Origin: https://frontend.com` 추가.

### 주요 특징
- **보안**: XSS나 CSRF 같은 공격 방지.
- **제한**: API 개발 시 프론트엔드와 백엔드 간 협업 필요.
- **우회 방법**: 
  - 서버 측 CORS 설정.
  - 프록시 서버 사용 (예: 개발 중 `localhost` 프록시).
  - JSONP (구형 방식, 권장 안 함).

### 요약
크로스 오리진은 웹 보안을 위한 필수 개념이며, CORS를 통해 안전하게 관리됩니다. 개발 시 서버 설정과 클라이언트 요청을 잘 맞춰야 원활한 통신이 가능합니다! 추가 질문 있으면 말씀해주세요.
---
프록시(Proxy)는 클라이언트와 서버 사이에서 중개 역할을 하는 시스템 또는 소프트웨어입니다. 네트워크 요청을 대신 처리하며, 보안, 성능, 접근 제어 등을 개선하는 데 사용됩니다.

### 주요 개념
- **역할**: 클라이언트의 요청을 받아 서버로 전달하고, 서버의 응답을 클라이언트로 돌려줌.
- **위치**: 클라이언트와 서버 사이에 위치 (예: 브라우저 → 프록시 → 웹 서버).

### 종류
1. **포워드 프록시 (Forward Proxy)**:
   - 클라이언트 대신 요청을 보내는 프록시.
   - 예: 회사 네트워크에서 외부 사이트 접속 시 IP 숨김, 접근 제어.
   - 용도: 익명성, 콘텐츠 필터링.

2. **리버스 프록시 (Reverse Proxy)**:
   - 서버 앞에 위치해 요청을 받아 적절한 백엔드 서버로 라우팅.
   - 예: `nginx`나 `Cloudflare`로 부하 분산, 캐싱.
   - 용도: 로드 밸런싱, 보안 강화(서버 IP 숨김).

### 주요 기능
- **캐싱**: 자주 요청되는 데이터를 저장해 응답 속도 향상.
- **보안**: 방화벽 역할, DDoS 방어, 데이터 암호화.
- **부하 분산**: 트래픽을 여러 서버로 분배.
- **우회**: 크로스 오리진 문제 해결 (예: 개발 중 CORS 우회).

### 예시
- **개발 환경**: `localhost:3000`에서 `api.example.com` 요청을 프록시로 보내 CORS 해결.
  - 설정 예: `proxy: "https://api.example.com"` (Webpack, Vite 등).
- **실제 사용**: VPN은 포워드 프록시의 일종으로 IP를 변경해 접속.

### 장점
- 성능 최적화, 보안 강화, 유연한 트래픽 관리.

### 단점
- 설정 복잡성, 프록시 자체가 단일 실패 지점(SPOF)이 될 수 있음.

프록시는 네트워크 통신에서 다재다능한 도구로, 상황에 따라 적절히 활용됩니다! 추가 질문 있으면 말씀해주세요.
---

