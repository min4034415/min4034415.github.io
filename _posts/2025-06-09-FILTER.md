---
title: ""
date: 2025-06-09
tags: []
author: "이의민"
---

### **필터 (Filter)**

* **개념**: 필터는 클라이언트의 요청(`request`)이 웹 서버의 최종 목적지(JSP, 서블릿, HTML 등)에 도달하기 전 또는 서버의 응답(`response`)이 클라이언트로 돌아가기 전에 `request`와 `response` 객체를 먼저 받아 사전/사후 작업 등 공통적으로 필요한 부분을 처리하는 기능입니다.

* **주요 역할 및 활용**:
    * **요청/응답 가로채기 및 수정**: 클라이언트로부터 들어오는 요청을 가로채서 내용을 변경하거나, 서버에서 나가는 응답 내용을 변경할 수 있습니다.
    * **로깅(Logging)**: 모든 요청에 대한 정보를 기록하는 데 사용될 수 있습니다.
    * **인코딩(Encoding) 처리**: 모든 요청에 대해 문자 인코딩을 일괄적으로 설정하여 한글 깨짐 문제를 방지할 수 있습니다. (예: `request.setCharacterEncoding("UTF-8");`)
    * **인증(Authentication) 및 인가(Authorization)**: 사용자가 로그인했는지, 특정 리소스에 접근할 권한이 있는지 등을 확인하여 접근을 제어할 수 있습니다.
    * **데이터 압축/암호화**: 요청이나 응답 데이터를 압축하거나 암호화하여 전송 효율 및 보안을 높일 수 있습니다.
    * **캐싱(Caching)**: 자주 요청되는 콘텐츠를 캐싱하여 성능을 향상시킬 수 있습니다.
    * **보안 강화**: SQL Injection, XSS 등의 공격을 방지하기 위해 입력 값 유효성 검사를 수행할 수 있습니다.

* **동작 방식 (다이어그램 설명)**:
    1.  **클라이언트(웹 브라우저)의 요청**: 클라이언트가 웹 서버로 요청을 보냅니다.
    2.  **필터 체인 통과 (사전 작업)**: 이 요청은 `JSP 컨테이너` 내에서 여러 개의 **필터**를 순차적으로 거치게 됩니다. 각 필터는 요청 객체(`request`)에 대한 사전 처리(예: 인코딩 설정, 로그인 여부 확인)를 수행합니다. 필터들은 체인(Chain) 형태로 연결되어 있어, 하나의 필터가 작업을 마친 후 다음 필터로 요청을 전달합니다.
    3.  **최종 목적지 도달**: 모든 필터를 통과한 요청은 최종 목적지인 **정적 리소스(JSP, 서블릿, HTML 등)**로 전달되어 처리됩니다.
    4.  **필터 체인 통과 (사후 작업)**: 최종 목적지에서 생성된 응답(`response`)은 다시 필터 체인을 역순으로 거치게 됩니다. 각 필터는 응답 객체에 대한 사후 처리(예: 응답 내용 압축, 특정 헤더 추가)를 수행합니다.
    5.  **클라이언트로 응답**: 모든 필터를 거친 최종 응답은 클라이언트(웹 브라우저)로 전달됩니다.

필터는 웹 애플리케이션의 공통적인 로직을 중앙 집중적으로 관리하고, 비즈니스 로직과 분리하여 코드의 재사용성과 유지보수성을 높이는 데 매우 효과적인 기술입니다.

---

### **필터 (Filter) 인터페이스**

필터는 클라이언트의 요청이 서블릿/JSP로 전달되기 전이나 응답이 클라이언트로 전달되기 전에 가로채서 특정 작업을 수행하는 데 사용되는 자바 클래스입니다.

#### **필터 인터페이스의 역할 및 구현**

* **핵심 역할**: 필터 기능을 구현하는 데 핵심적인 역할을 합니다.
* **구현 방식**: 클라이언트와 서버의 리소스(JSP, 서블릿 등) 사이에 위치한 필터의 기능을 제공하기 위해 자바 클래스로 구현됩니다.
* **클래스 구조**: `jakarta.servlet.Filter` (또는 과거 `javax.servlet.Filter`) 인터페이스를 구현해야 합니다.
    ```java
    import jakarta.servlet.*; // 또는 javax.
    
    public class 클래스 이름 implements Filter {
        // ... (생략)...
    }
    ```

#### **Filter 인터페이스 주요 메서드**

`Filter` 인터페이스를 구현하는 클래스는 세 가지 핵심 메서드를 반드시 오버라이드해야 합니다. 이 메서드들은 필터의 생명주기와 직접적으로 관련되어 있습니다.

1.  **`init()` 메서드**
    * **설명**: 필터 인스턴스의 초기화 메서드입니다. JSP 컨테이너(서블릿 컨테이너)가 필터를 최초로 인스턴스화하고 초기화 작업을 수행할 때 **단 한 번만 호출**됩니다.
    * **용도**: 필터가 서블릿의 서비스가 시작되기 전에 필요한 설정, 리소스 로딩(예: 설정 파일 읽기, 데이터베이스 연결 초기화) 등을 수행할 때 사용됩니다.
    * **메서드 시그니처**:
        ```java
        public void init(FilterConfig filterConfig) throws ServletException
        ```
        * `FilterConfig filterConfig`: `FilterConfig` 객체를 통해 필터의 초기화 매개변수(init-parameters)나 `ServletContext`에 접근할 수 있습니다.

2.  **`doFilter()` 메서드**
    * **설명**: 필터의 핵심 로직을 작성하는 메서드입니다. JSP 컨테이너가 필터를 리소스에 적용할 때마다, 즉 **클라이언트의 요청이 있을 때마다 호출**됩니다. `init()` 메서드 호출 이후 필터가 어떤 기능을 수행할 필요가 있을 때마다 호출됩니다.
    * **용도**: 요청 가로채기, 요청/응답 내용 변경, 인코딩 설정, 인증/권한 확인, 로깅 등 필터의 주된 기능이 이 메서드 내에서 구현됩니다.
    * **메서드 시그니처**:
        ```java
        public void doFilter(ServletRequest request, 
                             ServletResponse response,
                             FilterChain chain) 
                             throws java.io.IOException, ServletException
        ```
        * `ServletRequest request`: 체인을 따라 다음 필터나 최종 리소스로 전달할 요청 객체입니다.
        * `ServletResponse response`: 체인을 따라 다음 필터나 클라이언트로 전달할 응답 객체입니다.
        * `FilterChain chain`: 현재 필터 다음에 실행될 필터 또는 최종 리소스(서블릿/JSP)를 호출하는 데 사용됩니다. `chain.doFilter(request, response);`를 호출하여 다음 필터 또는 리소스로 제어를 넘깁니다. 만약 이 메서드를 호출하지 않으면 요청은 다음 단계로 진행되지 않고 현재 필터에서 처리가 종료될 수 있습니다.

3.  **`destroy()` 메서드**
    * **설명**: 필터 인스턴스를 종료하기 전에 호출되는 메서드입니다. JSP 컨테이너(서블릿 컨테이너)가 필터 인스턴스를 메모리에서 삭제하기 전에 호출되며, 필터가 사용했던 리소스(예: 열린 파일, 데이터베이스 연결)를 정리하고 해제하는 데 사용됩니다.
    * **용도**: 리소스 해제, 연결 닫기 등 클린업(cleanup) 작업을 수행합니다.
    * `destroy()` 메서드는 필터의 수명 동안 **단 한 번만 호출**됩니다.
    * **메서드 시그니처**:
        ```java
        public void destroy()
        ```

#### **FilterConfig 인터페이스 메서드**

`init()` 메서드의 매개변수로 전달되는 `FilterConfig` 객체는 필터의 초기화 정보를 얻는 데 사용됩니다.

| 메서드 | 반환 유형 | 설명 |
|---|---|---|
| `getFilterName()` | `String` | `web.xml` 파일에 설정된 필터의 이름( `<filter-name>`)을 반환합니다. |
| `getInitParameter(String name)` | `String` | `web.xml` 파일에 설정된 특정 초기화 매개변수(` <init-param>`의 ` <param-name>`)에 대한 ` <param-value>`를 반환합니다. 초기화 매개변수가 존재하지 않으면 `null`을 리턴합니다. |
| `getInitParameterNames()` | `Enumeration<String>` | `web.xml` 파일에 설정된 모든 초기화 매개변수의 이름(` <param-name>`) 목록을 `Enumeration<String>` 타입으로 반환합니다. 초기화 매개변수가 존재하지 않으면 비어있는 `Enumeration`을 반환합니다. |
| `getServletContext()` | `ServletContext` | 현재 웹 애플리케이션의 `ServletContext` 객체를 반환합니다. `ServletContext`를 통해 웹 애플리케이션의 전역적인 정보나 다른 리소스에 접근할 수 있습니다. |

이러한 메서드들을 통해 개발자는 웹 요청/응답 처리 과정에 유연하게 개입하여 다양한 공통 기능을 구현할 수 있습니다.
이번에 주신 이미지는 **`CharacterEncodingFilter`**에 대해 설명하고 있습니다.

---

### **`CharacterEncodingFilter` (문자 인코딩 필터)**

`CharacterEncodingFilter`는 웹 애플리케이션에서 문자 인코딩 문제를 해결하기 위해 사용되는 **필터(Filter)**의 한 종류입니다.

* **모든 요청에 대한 요청 문자셋 설정을 필터에서 하도록 함**:
    * 웹 애플리케이션에서는 클라이언트가 보낸 요청(특히 POST 방식)의 파라미터에 한글과 같은 다국어 문자가 포함되어 있을 때, 올바른 인코딩으로 설정해주지 않으면 문자가 깨지는 현상(encoding issue)이 발생할 수 있습니다.
    * `CharacterEncodingFilter`는 이러한 인코딩 설정을 모든 요청에 대해 일괄적으로 처리하도록 하는 역할을 합니다. 필터의 `doFilter()` 메서드 내에서 `request.setCharacterEncoding("UTF-8");`와 같은 코드를 실행하여 요청의 문자 인코딩을 지정합니다.

* **서블릿에서 개별적으로 설정할 필요 없어짐**:
    * `CharacterEncodingFilter`를 사용하지 않는다면, 각 서블릿이나 JSP 페이지에서 파라미터를 읽기 전에 `request.setCharacterEncoding("UTF-8");` 코드를 일일이 작성해야 합니다. 이는 코드 중복을 유발하고, 개발자가 실수로 누락할 경우 인코딩 문제가 발생할 수 있습니다.
    * 필터를 사용하면 이러한 반복적인 작업을 한 곳에서 처리할 수 있으므로, 각 서블릿/JSP의 코드를 간결하게 만들고 인코딩 설정을 놓치는 실수를 방지할 수 있습니다.

* **일반적으로 제일 먼저 해야 하는 작업이 됨**:
    * 요청의 문자 인코딩 설정은 파라미터를 읽기 전에 이루어져야 합니다. 파라미터를 한 번이라도 읽은 후에는 `setCharacterEncoding()` 메서드를 호출해도 적용되지 않습니다.
    * 따라서 `CharacterEncodingFilter`는 필터 체인(Filter Chain)에서 **가장 먼저 실행되도록 설정**하는 것이 일반적입니다. 이렇게 함으로써 모든 요청이 처리되기 전에 올바른 문자 인코딩이 보장됩니다.

**요약**:
`CharacterEncodingFilter`는 웹 애플리케이션에서 다국어 문자(특히 한글)가 포함된 요청의 인코딩 문제를 효과적으로 해결하기 위한 표준적인 방법입니다. 모든 요청에 대해 일관된 문자셋을 적용하여 개발의 편의성과 안정성을 높여줍니다.
